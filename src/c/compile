#!/usr/bin/env bash

set -e

rm -rf /wasm-output/*

cd emsdk/upstream/emscripten

# When the output file has the .mjs extension, emcc creates an ES module rather than a plain ol' JS script.

# The SINGLE_FILE option means we'll emit the wasm embedded as a base64 string within a JS file, along with all the glue JS;
# this makes it easier to bundle everything up with webpack - we don't have to serve the wasm separately.

# The EXPORTED_FUNCTIONS option tells emcc that we want the add function to be accessible from the compiled wasm
# (everything else might be removed if the compiiler can't see it being used). N.B. the underscore prefix is
# added by the compiler as part of the calling convention.

# The EXPORTED_RUNTIME_METHODS option tells emcc we want to use the cwrap function in our JS to interface with the wasm.
./emcc /source/"$FILENAME".c \
  -v \
  -o /wasm-output/"$FILENAME".js \
  -s SINGLE_FILE=1 \
  -s MODULARIZE=1 \
  -s EXPORTED_FUNCTIONS='["_multiply", "_forward_substitution", "_malloc", "_free"]' \
  -s EXPORTED_RUNTIME_METHODS='["cwrap"]' \
  -s EXTRA_EXPORTED_RUNTIME_METHODS='["getValue", "setValue"]' \
  -s ENVIRONMENT="node" \
  -s ASSERTIONS="$ASSERTIONS" \
  -s SAFE_HEAP="$SAFE_HEAP" \
  -s STACK_OVERFLOW_CHECK="$STACK_OVERFLOW_CHECK" \
  -s DEMANGLE_SUPPORT="$DEMANGLE_SUPPORT" \
  -Werror \
  -std=c11 \
  -"$OPTIMIZATION"

# We don't particularly want to keep the mjs extension
# mv /wasm-output/"$FILENAME".mjs /wasm-output/"$FILENAME".js

